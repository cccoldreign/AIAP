# Объектно-ориентированное программирование в Python

Объектно-ориентированная парадигма представляет собой методологию разработки ПО, в которой элементы программы (*это должны быть именно семантически значимые элементы — некоторые сущности, отражающие самостоятельные единицы в рамках предметной области*) представляются в виде объектов, которые обладают какими-либо свойствами (*атрибутами*) и каким-либо образом между собой и внешней средой взаимодействуют (при помощи *методов*).

Каждый объект принадлежит какому-либо **классу**.

**Класс** — модель объекта определенного типа, которая описывает его внутреннюю структуру и то, какие методы и алгоритмы доступны при взаимодействии объекта данного типа с другими объектами.

```python
class Pet:
    
    def __init__(self, tail='black', ears=('black', 'black')) -> None:
        self.tail = tail
        self.ears = ears
    
    def get_left_ear_color(self) -> str:
        return self.ears[0]

class Cat(Pet):
    
    def __init__(self, tail, ears, whiskers='black'):
        super().__init__()
        self.whiskers = whiskers
```

Классы могут **наследоваться** друг от друга — *дочерний класс* получает доступ к структуре и методам *родительского класса*, при этом он может добавлять в свою структуру новые элементы и методы.

Объединенные такими связями классы образуют *иерархию классов* в рамках отдельно взятого программного продукта.

**Наследование** — один из трех «китов» ООП. Два других — **инкапсуляция** и **полиморфизм**.

**Инкапсуляция** — возможность изолирования (сокрытия) конкретных элементов структуры и/или методов класса от внешних воздействий. По сути, это разделяет класс на методы и атрибуты, относящиеся к интерфейсу (в широком понимании — элементы, которые работают с внешней средой), и методы/атрибуты, непосредственно реализующие модель объекта, которую описывает класс.

Простыми словами: не во все методы и атрибуты класса мы можем тыкаться извне. В других языках программирования для инкапсуляции активно применяются модификаторы — `private`, `public`, `protected` и иные.

**Полиморфизм** — способность метода обрабатывать данные разных типов.

```python
def divider(a: int | float | str, b: int | float | str) -> float:
    if isinstance(a, str):
        a = float(a)
    if isinstance(b, str):
        b = float(b)
    return a / b
```

Базовым классом в Питоне является `object`. От него наследуются все остальные классы (в том числе неявное *<имплицитное, скрытое>* наследование, если вы создаете пользовательский класс и явно не наследуетесь ни от чего).

Чтобы посмотреть набор атрибутов и методов любого класса, можно вызвать встроенный метод `dir()`

```python
dir(object)

'''
[out]:

['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
'''
```

```python
p = Pet()
print(p.ears)
'''
[out]: ('black', 'black')
'''
int(5.7)
'''
[out]: 5
'''
int('5')
'''
[out]: 5
'''
```

```python
class Vehicle:

    def __init__(self, model: str, production_year: int, color: str | tuple[int, int, int], max_speed=0.0) -> None:
        self.model = model
        self.year = production_year
        self.color = color
        self.max_speed = max_speed  # максимальная скорость в км/ч
    
    def calc_min_hours(self, distance=0.0) -> float:
    '''Рассчитать минимальное количество часов (т.е. при езде с макс. скоростью) для преодоления заданного расстояния в километрах'''
    return distance / self.max_speed

class Bike(Vehicle):

    def __init__(self, model, production_year, color) -> None:
        super().__init__(model, production_year, color, 25)


b = Bike('BMX', 1990, 'black')
b.calc_min_hours(376)

'''
[out] 15.04
'''
```

Модификаторы защиты (`protected`, `private`, `public`) в Питоне отсутствуют. Для повторения их поведения предназначены специальные правила именования методов классов.

- `_single_leading_underscore`: указание на то, что объект должен использоваться только внутри класса или модуля; `from M import *` не импортирует такие объекты и методы (замечу: синтаксис с `*` сам по себе является плохой практикой — см. `using namespace std;` в C++, например)
- `single_trailing_underscore_`: конвенциональные имена для атрибутов и метода, чьи названия совпадают со встроенными объектами языка, но выгодны для понимания (например, `class_` вместо `class` — `Tkinter.Toplevel(master, class_='ClassName')`)
- `__double_leading_underscore`: name mangling — внутри класса такие атрибуты и методы в памяти всегда записываются как `_ИмяКласса__Метод`, например: `class FooBar`, у него есть метод `__tea`, в памяти (и во всех ссылках) он всегда будет `_FooBar__tea`, к нему нельзя обратиться как к `__tea`, только как к `_FooBar__tea`

```python
class Car(Vehicle):

    def __init__(self, model, production_year, color, max_speed=100.0):
        super().__init__(model, production_year, color, max_speed)
        self.trunk = list()

    def __check_trunk(self):
        return self.trunk
car1 = Car('BMW', 2002, 'white', 150)
print(dir(car1))
'''
[out]:
['_Car__check_trunk',
 '__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'calc_min_hours',
 'color',
 'max_speed',
 'model',
 'production_year',
 'trunk']
'''

car1.__check_trunk()

'''
[out]: AttributeError...
'''

car1._Car__check_trunk()
'''
[out]: []
'''

```

- `__double_leading_and_trailing_underscore__`, **dunder-методы**: «магические» методы, объекты и атрибуты. ==НИКОГДА== не изобретать свои магические методы, только использовать уже существующие в языке. К ним относятся, например, `__init__`, `__import__`, `__file__`, `__name__`, `__str__`, `__repr__`, все методы, определяющие поведение операторов сравнения, арифметических операторов, оператора присваивания и т.д.

При создании нового экземпляра класса сначала вызывается метод `__new__`, который и создает новый объект в памяти непосредственно (принимая сам класс как один из аргументов). Потом уже все аргументы передаются в `__init__` для инициализации.

`__new__` непосредственно описывается редко, т.к. чаще всего мы используем стандартную процедуру создания объекта, определенную еще в базовом классе иерархии классов языка `object`. НО: `__new__` может быть полезен, если вы наследуетесь от иммутабельного типа (можно изменить поведение в этот момент — до инициализации)

```python
class MyClass(object):
    def __new__(cls) -> MyClass:
        print('Создаем экземпляр в памяти...')
        return super(MyClass, cls).__new__(cls)

    def __init__(self) -> None:
        print('Пошла инициализация...')
MyClass()

"""
[out]:
Создаем экземпляр в памяти...
Пошла инициализация...
"""
```

> [!note]
> Если нужны абстрактные классы, то их база вынесена в Питоне в отдельный модуль стандартной библиотеки — `abc` (Abstract Base Classes). См. документацию: [abc — Abstract Base Classes — Python 3.12.0 documentation](https://docs.python.org/3/library/abc.html)

# Лабораторная работа №1: Особенности ООП в Python

1. Реализовать структуру данных «очередь» (первый пришел, первый ушел) с помощью класса с возможностью просмотра, добавления и удаления элементов.
2. Реализовать структуру данных «стек» (последний пришел, первый ушел) с помощью класса с возможностью просмотра, добавления и удаления элементов.
3. Реализовать иерархию классов, описывающих разные виды объектов одного типа (например, сервоприводов синхронный/асинхронный/линейный и т.п.). Реализовать минимум 3 уровня иерархии. Реализовать возможность задания характеристик (например, для двигателя это угол поворота, скорость вращения, ускорение и т.п.). Реализовать строковое представление классов «магическими» методами `__str__()` и `__repr__()`, быть готовым пояснить различия этих методов. Перегрузить условные операторы (см. магические методы `__eq__()`, `__ne__()`, `__lt__()`, `__gt__()`, `__le__()`, `__ge__()`) для реализации возможности сравнения экземпляров класса.
4. Реализовать упрощенную модель некоего объекта (например, шестизвенного манипулятора с сервоприводами) при помощи иерархии классов. Реализовать функции объекта (например, перемещение манипулятора в пространстве) через перегрузку арифметических операторов (`__add__()` и т.д.).
5. Расчет расстояния между точками на сфере по их широте и долготе (взять любые GPS-координаты) при помощи иерархии классов: как минимум, Точка и Сфера (к ней относятся Точки). https://en.wikipedia.org/wiki/Haversine_formula
