# Элементы декларативного программирования в Python

Декларативное программирование — парадигма, при которой определяется ожидаемый результат выполнения программы, а не последовательность отдельных шагов, которые к данному результату ведут.

Это отличает ее от императивной парадигмы, где внимание уделяется фиксации отдельных шагов, выполнение их в последовательности приведет к некоторому результату.

Функциональное программирование — подвид декларативного, при котором процесс выполнения программы интерпретируется концептуально как вычисление значений функций (в математическом определении функции).

К функциональным ЯП традиционно относят:

- LISP
- Haskell
- F#
- Scala
- Erlang -> Elixir
- даже Эксель-функции (т.к. Эксель полный по Тьюрингу)

При этом элементы функциональной парадигмы присутствуют во многих языках, включая Python.

```lisp
(+ (fibonacci (- N 1)) (fibonacci (- N 2)))))
```

```python
lambda n: reduce(lambda x, n: [x[1], x[0]+x[1]], range(n), [0, 1])[0]
```

## Включения (comprehensions)

Включения бывают списковые (list comprehensions) и словарные (dictionary comprehensions). Их объединяет то, что и то, и другое относится к генераторным выражениям ([PEP 289 – Generator Expressions | peps.python.org](https://peps.python.org/pep-0289/)), а отличаются они синтаксисом и, разумеется, итоговым продуктом — списком или словарем.

```python
lst_com = [x**4 for x in range(1000)]  # списковое включение
dct_com = { f'id_{x}': x**2 for x in range(1000) }  # словарное включение
```

## Генераторы (generators)

Генераторы — особый вид вычисляемых выражений, которые хранят в памяти только текущее значение и правило вычисления следующего результата выражения.

Генераторы можно итерировать только 1 раз и только вперед.

Для генерации следующего результата генератора существует специальный метод `next()`.

После исчерпания генератора его нужно пересоздать. 

Генератор можно итерировать как иную коллекцию (например, список или кортеж), но только 1 раз.

Однострочный генератор:

```python
gen_one = (x**4 for x in range(1000))
```

Многострочный генератор:

```python
def gen():
    for prog_idx, prog in enumerate(set_1):
        for mach_idx, mach in enumerate(prog):
            for work_idx, work in enumerate(mach):
                yield (prog_idx, mach_idx, work_idx)  # обратите внимание на ключевое слово — заменяет return
```

Генераторы позволяют с минимальными расходами памяти делать такое:

```python
for i in range(100_000_000_000_000_000):
    print(i)
```

Важно понимать, что генератор != коллекция, нельзя обратиться к конкретному элементу, можно только дойти до него через последовательную генерацию предыдущих.

```python
print(type([x**4 for x in range(1000)]))  # list
print(type((x**4 for x in range(1000))))  # generator
```

## Анонимные функции (лямбда-функции, лямбда-выражения, lambda)

```python
lambda x: math.sqrt(x)  # в памяти будет <function __main__.<lambda>(x)>

def foo():
    return math.sqrt(x) # в памяти будет <function __main__.foo()>
```

Анонимные функции, ад-хок функции — функции, описываемые непосредственно в блоке своего использования без выделения отдельного имени в памяти программы.

```python
import math

srt = lambda x: math.sqrt(x)  # но их все еще можно присваивать переменным, тем самым давая им понятное имя

srt(50)
srt(150)
```

Раскрываются анонимные функции тогда, когда нужно прямо на месте описать принцип достижения какого-либо результата (т.е. когда функции нужна здесь и сейчас, ее результат будет получен на месте и более, скорее всего, эта функции использоваться не предполагается)

```python
[skill in map(lambda x: x[0].lower(), cluster) for skill in context_skills]
```

## Функции высшего порядка (HOF, Higher-Order Functions)

Функция высшего порядка — функция,  которая принимает в качестве аргумента другую функцию и/или возвращает функцию как результат своего вычисления.

Т.к. в Питоне функция всегда является одновременно именованным объектом, никто не мешает передавать этот объект в качестве такого же аргумента в другие функции (аналогично другим, «обычным» переменным) либо возвращать его при выполнении функции.

```python
import sys

def display(fun, arg):
    print(f'{type(fun)} : {fun}')
    print(f'arg={arg} => fun(arg)={fun(arg)}'

if len(sys.argv) > 1: 
    n = float(sys.argv[ 1 ])
else:
    n = float( input( "число?: " ) )

def pow3( n ): # 1-е определение функции
    return n * n * n
display(pow3, n)

pow3_l = lambda n: n * n * n # 2-е определение функции с тем же именем
display(pow3_l, n)

display(( lambda n: n * n * n ), n) # 3-е, использование анонимного описание функции

'''
[out]
<class 'function'> : <function pow3 at 0xb74542ac>
arg=1.3 => fun( arg )=2.1970000000000005
<class 'function'> : <function <lambda> at 0xb745432c>
arg=1.3 => fun( arg )=2.1970000000000005
<class 'function'> : <function <lambda> at 0xb74542ec>
arg=1.3 => fun( arg )=2.1970000000000005
'''
```

### Функция map()

Применяет переданную функцию к каждому элементу в переданной последовательности и возвращает последовательность результатов (с той же размерностью, что и входная коллекция)

```python
[skill in map(lambda x: x[0].lower(), cluster) for skill in context_skills]
```

При этом не стоит забывать, что `map()` можно заменить списковым включением:

```python
[skill in [x[0].lower() for x in cluster] for skill in context_skills]
```

Иногда это даже предпочтительнее, т.к. `map()` возвращает не список или кортеж, а именно map-объект.

### Функция filter()

Применяет переданную функцию к каждому элементу коллекции и возвращает коллекцию только тех элементов исходной коллекции, для которых переданная функция вернула значение истинности.

```python
list(filter(lambda x: len(x) >= 3, ready_clusters))
```

При этом `filter()` всегда можно заменить генератором:

```python
(x for x in ready_clusters if len(x) >= 3)
```

>[!note]
>Функции `map()` и `filter()` возвращают не список, а особые объекты-итераторы

### Функция reduce()

Применяет переданную функцию к каждому значению в списке и ко внутреннему накопителю результата (на примерах обозначен переменной `a`) (агрегатору)

Например, вычисление факториала 10!:

```python
from functools import reduce

reduce(lambda a, m: a*m, range(1, 10))
```

```python
from functools import reduce

reduce(lambda a, b: a+b[1][0], [skill for skill in cluster if skill[1][1].lower() in context_skills], 0.0)
```

## Частичное применение функции (partial functions)

Частичное применение функции предполагает на основе функции `N` переменных определение новой функции с меньшим числом переменных `M`, причем обязательно, что `M < N`, при этом остальные `N - M` переменных получают фиксированные («замороженные») значения.

```python
from functools import partial

def mulPart(a: float, b: float) -> float:
    return a * b

par3 = partial(mulPart, 3)  # заморозка первого аргумента функции на значении 3

print(par3(3), par3(5)) # частичное применение функции
# 9, 15
```

## Замыкания (Closures)

Функция, которая возвращает другую функцию с «замороженным» на момент определения набором данных.

```python
def mulClosure(a: float):
    def mulFull(b: float) -> float:
        return a * b
    return mulFull

closure3 = mulClosure(3)  # функция умножения на 3

print(closure3(3), closure3(5)) # применение замыканий
# 9, 15
```

## Функторы

Функтор — объект некоторого класса, который может быть вызван как функция.

В Python любой объект с определенным методом `__call__()` является функтором.

```python
class mulFunctor:
    def __init__(self, a: float):
        self.a:float = a
    def __call__(self, b: float) -> float:
        return self.a * b

functor3 = mulFunctor(3)  # создаем функтор (экземпляр класса)

print(functor3(3), functor3(5)) # вызываем функтор как функцию
# 9, 15
```

## Каррирование (Currying)

Каррирование (или транслитерацией карринг) — преобразование функции от многих переменных в функцию, принимающую 1 аргумент за 1 вызов (т.е. берущую их по одному).

>[!info]
>Такое преобразование было названо в честь Хаскелла Карри (того же, в честь кого назвали Haskell).
>Впервые каррирование ввели М. Шейнфинкель и Г. Фреге

В некоторых «изначально» функциональных ЯП (Haskell, ML) существует отдельный оператор каррирования. В иных случаях любой язык, поддерживающий замыкания, включая Python, Perl, C++, поддерживает и каррирование.

```python
def mulFull(a: float, b: float) -> float:
    return a * b

curryMul = lambda x: lambda y: mulFull(x, y)

print(curryMul(3)(3), curryMul(3)(5))  # каррирование
# 9, 15

# Сравним с замыканиями

def mulClosure(a: float):
    def mulFull(b: float) -> float:
        return a * b
    return mulFull

print(mulClosure(3)(3), mulClosure(3)(5)) # применение замыканий
# 9, 15
```

# Лабораторная работа №3: Элементы функционального программирования в Python

## Блок 1

1. Загрузите список стран из `countries.json`
2. С помощью `map()` создайте новый список, изменив сделав название каждой страны прописным в списке стран.
3. С помощью `filter()`, чтобы отфильтровать страны, содержащие `'land'`.
4. С помощью `filter()`, чтобы отфильтровать страны, содержащие ровно шесть символов.
5. С помощью `filter()`, чтобы отфильтровать страны, содержащие шесть и более букв в списке стран.
6. С помощью `filter()` для отсеивания стран, начинающихся с буквы `'E'`.
7. С помощью `reduce()` объедините все страны и получите данное предложение на английском языке: Финляндия, Швеция, Дания, Норвегия и Исландия являются странами Северной Европы.
8. Решите предыдущие задачи, объединив две или более функций высшего порядка методов
9. Используя сначала каррирование, а затем замыкания, объявите функцию `categorize_countries()`, которая возвращает список стран с некоторым общим шаблоном (например, `'land', 'ia', 'island', 'stan'`), который можно менять.
10. Используя файл `countries-data.json`, выполните приведенные ниже задания в функциональной парадигме:
    1. Отсортировать страны:
        1. по названию, 
        2. по столице, 
        3. по численности населения
    2. Выявить произвольное число (начать с 10) наиболее распространенных языков и где их используют.
    3. Выявить произвольное число (начать с 10) наиболее населенных стран.

## Блок 2

1. Сгенерировать список из 50 числовых элементов. Используя списковые включения, вычислить 4, 5 и 6 степени каждого элемента.
2. Сгенерировать матрицу в виде списка списков (например, `[ [1, 2], [3, 4], [5, 6], [7, 8], [1, 2], [3, 4], [5, 6], [7,8] ]`). Используя списковые включения, транспонировать матрицу ([https://ru.wikipedia.org/wiki/Транспонированная_матрица)](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0))
3. Взять полный диапазон числовых элементов от -9999 до 9999. Используя анонимную функцию и функцию `filter()`, вывести список, содержащий все элементы, которые без остатка делятся на 36.
4. Используя `map()` и анонимные функции (а также любые вспомогательные методы `str`), написать функцию редактирования заголовков в англоязычном стиле (`Каждое Слово Длиной Более 3 Букв Должно Быть с Большой Буквы`), принимающую на вход исходную строку, возвращающую отредактированную строку.
5. Используя иерархию классов из лаб. работы № 1, встроенные коллекции, анонимные функции и `reduce()`, вернуть максимальную длину, на которую может вытянуться шестизвенный манипулятор. Классы в иерархии можно расширять при необходимости.
6. Используя частичное выполнение функции, заменить указанную функцию с 4 аргументами на функцию с 1 аргументом так, чтобы результат был равен:
    1. 60
    2. 120
    3. 180

```python
def foo(a:int, b:int, c:int, d:int) -> int:
    return a*4 + b*3 + c*2 + d
```

7. Используя 2 генератора и `sum()`, вернуть сумму квадратов первых 10, 20, 30, 40 и 50 чисел Фибоначчи.
8. Написать генератор, последовательно возвращающий **все** аэропорты из списка IATA. Каждый аэропорты должен быть выведен в виде словаря, где ключами являются параметры из списка на Википедии (например, заголовки колонок таблицы здесь [https://en.wikipedia.org/wiki/List_of_airports_by_IATA_airport_code:\_A)](https://en.wikipedia.org/wiki/List_of_airports_by_IATA_airport_code:_A)) значениями — данные самого аэропорта.
9. Используя генератор из п. 8, сохранить в текстовый файл список IATA-кодов аэропортов и их англоязычные названия, разделенные табуляцией (`\t`).